pragma silverscript ^0.1.0;

// ============================================================
// KAST v2 Phase 2: Immediate Anonymization Contract
// ============================================================
// Locking script on each voter's identifiable token UTXO.
//
// v2 changes from v1:
//   - MIN_AGE removed (JIT flow: mint and anonymize immediately)
//   - TOKEN_VAL = 0.1 KAS
//   - recover entrypoint: election authority can reclaim deposit
//     after electionEnd if voter never anonymized
//
// Physical flow at polling station:
//   1. Voter presents QR1 (identity wallet)
//   2. Station verifies identity (off-chain)
//   3. Commission mints token to QR1 (Phase 1)
//   4. Voter + Station co-sign burn TX (this contract)
//   5. Anonymous QR2 token issued (fresh keypair on terminal)
//   6. Voter receives QR2 paper/screen
//
// Security model:
//   - 2-of-2: voter key (QR1) + station terminal key
//   - Stolen QR1 alone is useless without station co-sign
//   - Physical handoff breaks voter<->ballot link
//   - Batch timing: TXs buffered and broadcast in batches
//     to prevent timing correlation on-chain
//
// Constructor args (per-voter, compiled individually):
//   voterPk           = voter's public key (baked into QR1)
//   stationPk         = polling station terminal's public key
//   electionAuthority = commission pubkey (for deposit recovery)
//   electionEnd       = locktime after which recovery is allowed
//
// Future: OpZkPrecompile for cryptographic anonymization
// ============================================================

contract KASTAnonV2(pubkey voterPk, pubkey stationPk, pubkey electionAuthority, int electionEnd) {
    int constant TOKEN_VAL = 10000000;

    // ----------------------------------------------------------
    // anonymize: Voter + Station co-sign to create anonymous token
    // ----------------------------------------------------------
    entrypoint function anonymize(sig voterSig, sig stationSig) {
        // ---- Authorization: 2-of-2 ----
        require(checkSig(voterSig, voterPk));
        require(checkSig(stationSig, stationPk));

        // ---- Output constraints ----
        // Exactly 1 output: the anonymous token
        require(tx.outputs.length == 1);

        // Value preservation (exact — prevents fingerprinting)
        require(tx.outputs[0].value == TOKEN_VAL);

        // ---- Covenant chain ----
        // Anonymous token continues the election covenant
        bytes covId = OpInputCovenantId(this.activeInputIndex);
        require(OpCovOutCount(covId) == 1);
    }

    // ----------------------------------------------------------
    // recover: Election authority reclaims deposit after election
    // ----------------------------------------------------------
    // If voter never anonymized (walked away, lost QR1, etc.),
    // the token UTXO would be locked forever. This entrypoint
    // allows the authority to recover the deposit after election.
    // ----------------------------------------------------------
    entrypoint function recover(sig authSig) {
        require(checkSig(authSig, electionAuthority));
        require(tx.time >= electionEnd);

        // Terminate covenant chain — prevent phantom UTXO creation
        bytes covId = OpInputCovenantId(this.activeInputIndex);
        require(OpCovOutCount(covId) == 0);
    }
}
